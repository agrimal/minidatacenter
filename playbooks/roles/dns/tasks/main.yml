---
# role dns - file main.yml

- name: Update repositories cache and install bind9 relative packages
  action: >
    {{ ansible_pkg_mgr }} name={{ item }} update_cache=yes cache_valid_time=3600 state=present
  with_items:
    - bind9
    - bind9-doc
    - python3-dns
    - python3-dnsq
    - python3-pip

- name: Verify that /var/log/bind directory exists
  file:
    path: /var/log/bind
    state: directory
    mode: 0755
    owner: bind
    group: bind

- name: Disable and stop the systemd-resolved service
  systemd:
    name: systemd-resolved
    state: stopped
    enabled: no

- name: Modify /etc/resolv.conf
  template:
    src: "{{ role_path }}/templates/main_resolv.conf.j2"
    dest: /etc/resolv.conf
    owner: root
    group: root
    mode: 0644

- name: Verify that the "/etc/bind" directory exists
  file:
    path: /etc/bind
    state: directory
    mode: 0755
    owner: bind
    group: root

- name: Modify "/etc/default/bind9" to listen on IPv4 only and work this 2 threads
  lineinfile:
    path: /etc/default/bind9
    regexp: '^OPTIONS="'
    line: 'OPTIONS="-u bind -4 -n 2"'
  register: etc_default_bind9_task

# need dns_cidr_clients, dns_cidr_authorized_admin_ip
- name: Generate the "/etc/bind/named.conf.options" file
  template:
    src: "{{ role_path }}/templates/main_named.conf.options.j2"
    dest: /etc/bind/named.conf.options
    owner: root
    group: bind
    mode: 0644
  register: etc_bind_named_conf_options_task

- name: Copy the "/etc/bind/named.conf.logs" file
  copy:
    src: "{{ role_path }}/files/main_named.conf.logs"
    dest: /etc/bind/named.conf.logs
    owner: root
    group: bind
    mode: 0644
  register: etc_bind_named_conf_logs_task

- name: Copy the "named.conf" file
  template:
    src: "{{ role_path }}/templates/main_named.conf.j2"
    dest: "/etc/bind/named.conf"
    owner: root
    group: bind
    mode: 0644
  register: etc_bind_named_conf_task

# localhost
- name: Check if "{{ ansible_working_directory }}/{{ inventory_hostname }}/etc/bind" exists on localhost
  local_action:
    module: stat
    path: "{{ ansible_working_directory }}/{{ inventory_hostname }}/etc/bind"
  register: local_etc_bind

# localhost
- name: Find ".key" and ".private" files in "{{ ansible_working_directory }}/{{ inventory_hostname }}/etc/bind" on localhost
  local_action:
    module: find
    path: "{{ ansible_working_directory }}/{{ inventory_hostname }}/etc/bind/"
    use_regex: yes
    patterns: '^K.*\.(key|private)$'
    recurse: no
  when:
    - not ansible_renew_all 
    - local_etc_bind.stat.exists
  register: local_etc_bind_find_result

- name: Find ".key" and ".private" files in "/etc/bind"
  find:
    path: /etc/bind
    use_regex: yes
    patterns: '^K.*\.(key|private)$'
    recurse: no
  register: remote_etc_bind_find_result

# localhost
- name: Generate the list of ".key" and ".private" files in "{{ ansible_working_directory }}/{{ inventory_hostname }}/etc/bind" on localhost
  set_fact:
    local_tsig_key_files: "{{ local_etc_bind_find_result.files | map(attribute='path') | list }}"
  when:
    - not ansible_renew_all
    - local_etc_bind.stat.exists

- name: Generate the list of ".key" and ".private" files in "/etc/bind"
  set_fact:
    remote_tsig_key_files: "{{ remote_etc_bind_find_result.files | map(attribute='path') | list }}"

- name: Decide wether all TSIG files should be deleted or not
  set_fact:
    ansible_renew_all: True
  when:
    - ansible_renew_all or
      (local_tsig_key_files is defined) and (local_tsig_key_files | length != 2) or
      (remote_tsig_key_files is defined) and (remote_tsig_key_files | length != 2)

# localhost
- name: Delete all files in "{{ ansible_working_directory }}/{{ inventory_hostname }}/etc/bind"
  local_action:
    module: file
    state: "{{ item }}"
    path: "{{ ansible_working_directory }}/{{ inventory_hostname }}/etc/bind"
    owner: root
    group: root
    mode: 0755
  with_items:
    - absent
    - directory
  when:
    - ansible_renew_all
  register: local_etc_bind_delete_task

- name: Delete ".key" and ".private" files in "/etc/bind"
  file:
    state: absent
    path: "{{ item }}"
  with_items:
    - "{{ remote_tsig_key_files }}"
  when:
    - ansible_renew_all
  register: remote_etc_bind_delete_task

# Generate new TSIG files
- name: Generate TSIG key "{{ dns_tsig_key_name }}"
  command: dnssec-keygen -a HMAC-SHA512 -b 512 -K /etc/bind -r /dev/urandom -n HOST "{{ dns_tsig_key_name }}"
  when:
    - ansible_renew_all
  register: tsig_key_generate_task

# Fetch them if they are new
- name: Fetch the new TSIG key files from /etc/bind to "{{ ansible_working_directory }}/{{ inventory_hostname }}/etc/bind"
  fetch:
    src: "/etc/bind/{{ item }}"
    dest: "{{ ansible_working_directory }}"
  with_items:
    - "{{ tsig_key_generate_task.stdout + '.private' }}"
    - "{{ tsig_key_generate_task.stdout + '.key' }}"
  when:
    - ansible_renew_all

# Else verify local against remote keys
- name: Verify the TSIG key files in /etc/bind are identical to those in "{{ ansible_working_directory }}/{{ inventory_hostname }}/etc/bind"
  fetch:
    src: "{{ item }}"
    dest: "{{ ansible_working_directory }}"
  with_items:
    - "{{ remote_tsig_key_files }}"
  when:
    - remote_tsig_key_files is defined
    - not ansible_renew_all

# localhost
- name: Read ".key" file if it was renewed
  local_action:
    module: slurp
    path: "{{ ansible_working_directory }}/{{ inventory_hostname }}/etc/bind/{{ tsig_key_generate_task.stdout }}.key"
  when:
    - ansible_renew_all
  register: local_tsig_key_private_file_changed

- name: Read ".key" file if it was left unchanged
  local_action:
    module: slurp
    path: "{{ ansible_working_directory }}/{{ inventory_hostname }}{{ item }}"
  with_items:
    - "{{ remote_tsig_key_files | select('match', '^.*key$') | list }}"
  when:
    - not ansible_renew_all
  register: local_tsig_key_private_file_unchanged

- name: Extract key name and secret from ".key" file if it was left unchanged
  set_fact:
    dns_tsig_key_secret: "{{ item.content | b64decode | regex_replace('^.* IN KEY [0-9]{3} [0-9] [0-9]{3} (.*) (.*)\n$', '\\1\\2') }}"
    dns_tsig_key_name: "{{ item.content | b64decode | regex_replace('^(.*)\\. IN KEY.*\n$', '\\1') }}"
  with_items:
    - "{{ local_tsig_key_private_file_unchanged.results }}"
  when:
    - not ansible_renew_all

- name: Extract key name and secret from ".key" file when it was renewed
  set_fact:
    dns_tsig_key_secret: "{{ item.content | b64decode | regex_replace('^.* IN KEY [0-9]{3} [0-9] [0-9]{3} (.*) (.*)\n$', '\\1\\2') }}"
    dns_tsig_key_name: "{{ item.content | b64decode | regex_replace('^(.*)\\. IN KEY.*\n$', '\\1') }}"
  with_items:
    - "{{ local_tsig_key_private_file_changed }}"
  when:
    - ansible_renew_all

# need dns_tsig_key_name, dns_tsig_key_algorithm and dns_tsig_key_secret
- name: Convert TSIG key for being readable by bind and push it into "/etc/bind/named.conf.{{ dns_tsig_key_name }}"
  template:
    src: "{{ role_path }}/templates/main_tsig_key.j2"
    dest: "/etc/bind/named.conf.{{ dns_tsig_key_name }}"
    owner: root
    group: bind
    mode: 0644

- name: Fetch the converted TSIG key file from /etc/bind/ to "{{ ansible_working_directory }}/{{ inventory_hostname }}/etc/bind" on localhost
  fetch:
    src: "/etc/bind/named.conf.{{ dns_tsig_key_name }}"
    dest: "{{ ansible_working_directory }}"

- name: Initialize empty dictionaries
  set_fact:
    dns_master_ptr_zones: {}
    reversed_forward_dict: {}
    reversed_reverse_dict: {}

- name: Calculate the PTR zones when 1 < network mask < 9 
  set_fact:
    dns_master_ptr_zones: "{{ dns_master_ptr_zones | combine( { item.key : item.value | ipaddr('revdns') | regex_replace( '^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.', '') } ) }}"
  with_dict: "{{ dns_master_zones }}"
  when:
    - 1 < (item.value | ipaddr('prefix')) < 9

- name: Calculate the PTR zones when 8 < network mask < 16
  set_fact:
    dns_master_ptr_zones: "{{ dns_master_ptr_zones | combine( { item.key: item.value | ipaddr('revdns') | regex_replace('^\\d{1,3}\\.\\d{1,3}\\.', '') } ) }}"
  with_dict: "{{ dns_master_zones }}"
  when:
    - 8 < (item.value | ipaddr('prefix')) < 17

- name: Calculate the PTR zones when 16 < network mask
  set_fact:
    dns_master_ptr_zones: "{{ dns_master_ptr_zones | combine( { item.key: item.value | ipaddr('revdns') | regex_replace('^[0-9]{1,3}\\.', '') } ) }}"
  with_dict: "{{ dns_master_zones }}"
  when:
    - 16 < (item.value | ipaddr('prefix'))

# need dns_master_zones, dns_master_ptr_zones and dns_tsig_key_name
- name: Generate the "/etc/bind/named.conf.local" file
  template:
    src: "{{ role_path }}/templates/main_named.conf.local.j2"
    dest: /etc/bind/named.conf.local
    owner: root
    group: bind
    mode: 0644
  register: etc_bind_named_conf_local_task

- name: Create dynamic forward zone files
  template:
    src: "{{ role_path }}/templates/main_db_forward.j2"
    dest: "/var/lib/bind/db.{{ item.key }}"
  with_dict: "{{ dns_master_zones }}"
  register: dynamic_forward_zones_task
  when:
    - ansible_renew_all 

- name: Create dynamic reverse zone files
  template:
    src: "{{ role_path }}/templates/main_db_reverse.j2"
    dest: "/var/lib/bind/db.{{ item.value | regex_replace('.in-addr.arpa.', '') }}"
  with_dict: "{{ dns_master_ptr_zones }}"
  register: dynamic_reverse_zones_task
  when:
    - ansible_renew_all 

- include_tasks: logrotate.yml

- name: Verify bind configuration
  command: named-checkconf -z
  changed_when: False

- name: Reload bind
  systemd:
    name: bind9
    state: reloaded
  when:
    - ansible_renew_all or
      etc_bind_named_conf_options_task.changed or
      etc_bind_named_conf_logs_task.changed or
      etc_bind_named_conf_local_task.changed or
      etc_bind_named_conf_task.changed or
      dynamic_forward_zones_task.changed or
      dynamic_reverse_zones_task.changed

- name: Revert forward zones dictionary
  vars:
    dns_master_zones_list: []
  set_fact:
    dns_master_zones_list: "{{ dns_master_zones_list + [item.key] }}"
    reversed_forward_dict: "{{ reversed_forward_dict | combine( { item.value : item.key } ) }}"
  with_dict: "{{ dns_master_zones }}"

- name: Revert reverse zones dictionary
  set_fact:
    reversed_reverse_dict: "{{ reversed_reverse_dict | combine( { item.value : item.key } ) }}"
  with_dict: "{{ dns_master_ptr_zones }}"

- name: Try to read the file "/var/lib/dhcp/dhcpd.leases" from DHCP pairs
  slurp:
    src: /var/lib/dhcp/dhcpd.leases
  with_items:
    - "{{ dns_pair_dhcp }}"
  delegate_to: "{{ item }}"
  failed_when: False
  register: slurp_dhcp_leases_task

- debug:
    var: slurp_dhcp_leases_task

- name: Make a list of DHCP leases
  set_fact:
    dhcp_leases_basic: "{{ item.content | b64decode | regex_findall('(?s)\\nlease.*?\\n}') | list }}"
  with_items:
    - "{{ slurp_dhcp_leases_task.results }}"
  no_log: true
  when:
    - "(item.msg is not defined) or (item.msg is defined and 'file not found' not in item.msg)"

- debug:
    var: dhcp_leases_basic

- name: Remove useless data from the list of DHCP leases
  vars:
    dhcp_leases_precise: []
  set_fact:
    dhcp_leases_precise: "{{ dhcp_leases_precise + [[item | regex_search('lease .*? {') | regex_replace('lease (.*) {', '\\1'), item | regex_search('ddns-rev-name = \".*?\"') | regex_replace('.*\"(.*)\".*', '\\1'), item | regex_search('ddns-txt = \".*?\"') | regex_replace('.*\"(.*)\".*', '\\1'), item | regex_search('ddns-fwd-name = \".*?\"') | regex_replace('.*\"(.*)\".*', '\\1'), item | regex_search('client-hostname \".*?\"') | regex_replace('.*\"(.*)\".*', '\\1')]] }}"
  with_items:
    - "{{ dhcp_leases_basic }}"

- debug:
    var: dhcp_leases_precise

- name: Make the lists of records in the DHCP leases
  vars:
    ptr_records_in_dhcp: []
    a_records_in_dhcp: []
  set_fact:
    ptr_records_in_dhcp: "{{ ptr_records_in_dhcp + [[item.1, item.4, (item.3 | regex_replace(item.4 + '\\.(.*)', '\\1'))]] }}"
    a_records_in_dhcp: "{{ a_records_in_dhcp + [[item.4, (item.3 | regex_replace(item.4 + '\\.(.*)', '\\1')), item.0]] }}"
  with_items:
    - "{{ dhcp_leases_precise }}"
  when:
    - item.0 != 'None'
    - item.1 != 'None'
    - item.2 != 'None'
    - item.3 != 'None'
    - item.4 != 'None'

- debug:
    var: ptr_records_in_dhcp

- debug:
    var: a_records_in_dhcp

- name: Dig the forward zones
  command: "dig axfr -k {{ remote_tsig_key_files | select('match', '^.*private$') | list | join('') }} {{ item.key }}"
  with_dict: "{{ dns_master_zones }}"
  changed_when: False
  register: dig_forward_command

- name: Filter A records in the result of the dig of forward zones
  no_log: True
  vars:
    dns_a_records: []
  set_fact:
    dns_a_records: "{{ dns_a_records + [ item.stdout_lines | map('regex_search', '.*[ \\t]A[ \\t].*') | select('string') | map('regex_replace', '^(.*)[ \\t][0-9]+[ \\t]IN[ \\t]A[ \\t](.*)$', '\\1 \\2') | list ] | sum(start=[]) }}"
    delete_list_forward_zones: "{{ dns_a_records + [ item.stdout_lines | map('regex_search', '.*[ \\t]A[ \\t].*') | select('string') | map('regex_replace', '^(.*)[ \\t][0-9]+[ \\t]IN[ \\t]A[ \\t](.*)$', '\\1 \\2') | list ] | sum(start=[]) }}"
  with_items:
    - "{{ dig_forward_command.results }}"

- name: Looking for A records to delete from the {{ delete_list_forward_zones | length }} records found in the forward zones
  set_fact:
    delete_list_forward_zones: "{{ delete_list_forward_zones | map( 'regex_replace', (item.0.name + '.*' + (item.1 | ipaddr('address'))) ) | select('match', '[a-zA-Z0-9-]') | list }}"
  with_subelements:
    - "{{ all_hosts_ips }}"
    - "ip"

- name: Build the combination list of "dns." + master zones
  vars:
    - dns_dot_zone_list: []
  set_fact:
    dns_dot_zone_list: "{{ dns_dot_zone_list + ['dns.' + item + '.'] }}"
  with_items:
    - "{{ dns_master_zones_list }}"

- name: Build the combination list of "dns." + master zones + IP address of the DNS container
  vars:
    - dns_dot_zone_ip_list: []  
  set_fact:
    dns_dot_zone_ip_list: "{{ dns_dot_zone_ip_list + [ dns_dot_zone_list | map('regex_replace', '^(.*)$', ('\\1 ' + item)) | list ] | sum(start = []) }}"
  with_items:
    - "{{ ansible_all_ipv4_addresses }}"

- name: Make the difference between A records list and combination of possible DNS records to not delete them
  set_fact:
    delete_list_forward_zones: "{{ delete_list_forward_zones | difference(dns_dot_zone_ip_list) }}"

- name: Format the A records delete list
  vars:
    temporary_delete_list: []
  set_fact:
    temporary_delete_list: "{{ temporary_delete_list + [item.split(' ')] }}"
  with_items:
    - "{{ delete_list_forward_zones }}"

- name: Format the A records delete list again
  vars:
    final_delete_list_forward_zones: []
  set_fact:
    final_delete_list_forward_zones: "{{ final_delete_list_forward_zones + [ item.0.split('.', 1) + [item.1] ] }}"
  with_items:
    - "{{ temporary_delete_list }}"
  when:
    - temporary_delete_list is defined

- name: Remove from the A records delete list the records obtained from DHCP leases
  set_fact:
    final_delete_list_forward_zones: "{{ final_delete_list_forward_zones | difference(a_records_in_dhcp) }}"
  when:
    - final_delete_list_forward_zones is defined
    - a_records_in_dhcp is defined

- debug:
    var: final_delete_list_forward_zones

- name: Delete obsolote A records in forward zones
  nsupdate:
    key_name: "{{ dns_tsig_key_name }}"
    key_secret: "{{ dns_tsig_key_secret }}"
    key_algorithm: "{{ dns_tsig_key_algorithm | lower }}"
    server: "{{ ansible_host }}"
    zone: "{{ item.1 }}"
    record: "{{ item.0 + '.' + item.1 }}"
    value: "{{ item.2 }}"
    state: "absent"
  with_items:
    - "{{ final_delete_list_forward_zones }}"
  when:
    - final_delete_list_forward_zones is defined

- name: Fill the forward zones with A records
  nsupdate:
    key_name: "{{ dns_tsig_key_name }}"
    key_secret: "{{ dns_tsig_key_secret }}"
    key_algorithm: "{{ dns_tsig_key_algorithm | lower }}"
    server: "{{ ansible_host }}"
    zone: "{{ reversed_forward_dict[ item.1 | ipaddr('network/prefix') ] }}"
    record: "{{ item.0.name }}"
    value: "{{ item.1 | ipaddr('address') }}"
    state: "present"
    ttl: 86400
  with_subelements:
    - "{{ all_hosts_ips }}"
    - "ip"

- name: Dig the reverse zones
  command: "dig axfr -k {{ remote_tsig_key_files | select('match', '^.*private$') | list | join('') }} {{ item.value }}"
  with_dict: "{{ dns_master_ptr_zones }}"
  changed_when: False
  register: dig_reverse_command

- name: Filter PTR records in the result of the dig of reverse zones
  no_log: True
  vars:
    dns_ptr_records: []
  set_fact:
    dns_ptr_records: "{{ dns_ptr_records + [ item.stdout_lines | map('regex_search', '.*[ \\t]PTR[ \\t].*') | select('string') | map('regex_replace', '^(.*)[ \\t][0-9]+[ \\t]IN[ \\t]PTR[ \\t](.*)$', '\\1 \\2') | list ] | sum(start=[]) }}"
    delete_list_reverse_zones: "{{ dns_ptr_records + [ item.stdout_lines | map('regex_search', '.*[ \\t]PTR[ \\t].*') | select('string') | map('regex_replace', '^(.*)[ \\t][0-9]+[ \\t]IN[ \\t]PTR[ \\t](.*)$', '\\1 \\2') | list ] | sum(start=[]) }}"
  with_items:
    - "{{ dig_reverse_command.results }}"

- name: Looking for PTR records to delete from the {{ delete_list_reverse_zones | length }} records found in the reverse zones
  set_fact:
    delete_list_reverse_zones: "{{ delete_list_reverse_zones | map( 'regex_replace', ((item.1 | ipaddr('revdns')) + ' ' + item.0.name + '.*')) | select('match', '[a-zA-Z0-9-]') | list }}"
  with_subelements:
    - "{{ all_hosts_ips }}"
    - "ip"

- name: Format the PTR records delete list
  vars:
    temporary_reverse_delete_list: []
  set_fact:
    temporary_reverse_delete_list: "{{ temporary_reverse_delete_list + [item.split(' ')] }}"
  with_items:
    - "{{ delete_list_reverse_zones }}"

- name: Format the PTR records delete list again
  vars:
    final_delete_list_reverse_zones: []
  set_fact:
    final_delete_list_reverse_zones: "{{ final_delete_list_reverse_zones + [[item.0] + item.1.split('.', 1)] }}"
  with_items:
    - "{{ temporary_reverse_delete_list }}"
  when:
    - temporary_reverse_delete_list is defined

- name: Remove from the PTR records delete list the records obtained from DHCP leases
  set_fact:
    final_delete_list_reverse_zones: "{{ final_delete_list_reverse_zones | difference(ptr_records_in_dhcp) }}"
  when:
    - final_delete_list_reverse_zones is defined
    - ptr_records_in_dhcp is defined

- debug:
    var: final_delete_list_reverse_zones

- name: Delete obsolote PTR records in reverse zones
  nsupdate:
    key_name: "{{ dns_tsig_key_name }}"
    key_secret: "{{ dns_tsig_key_secret }}"
    key_algorithm: "{{ dns_tsig_key_algorithm | lower }}"
    server: "{{ ansible_host }}"
    zone: "{{ dns_master_ptr_zones[item.2[:-1]] }}"
    record: "{{ item.0 }}"
    value: "{{ item.1 + '.' + item.2 }}"
    state: "absent"
    type: "PTR"
  with_items:
    - "{{ final_delete_list_reverse_zones }}"
  when:
    - final_delete_list_reverse_zones is defined

- name: Fill the reverse zones with PTR records
  nsupdate:
    key_name: "{{ dns_tsig_key_name }}"
    key_secret: "{{ dns_tsig_key_secret }}"
    key_algorithm: "{{ dns_tsig_key_algorithm | lower }}"
    server: "{{ ansible_host }}"
    zone: "{{ dns_master_ptr_zones[reversed_forward_dict[ item.1 | ipaddr('network/prefix') ]] }}"
    record: "{{ item.1 | ipaddr('revdns') }}"
    value: "{{ item.0.name }}.{{ reversed_forward_dict[ item.1 | ipaddr('network/prefix') ] }}."
    type: "PTR"
    ttl: 86400
  with_subelements:
    - "{{ all_hosts_ips }}"
    - "ip"
